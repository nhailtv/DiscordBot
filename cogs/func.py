import os
import discord
from discord.ext import commands
from discord.ui import Button, View
import google.generativeai as genai
import asyncio

# Google AI Key
GEMINI_API_KEY = os.getenv("GOOGLE_AI_KEY")

# AI Configuration
genai.configure(api_key=GEMINI_API_KEY)

class FuncCommand(commands.Cog, name="func"):
    def __init__(self, bot) -> None:
        self.bot = bot

    @commands.hybrid_command(
        name="func",
        description="Generates a Python file based on your request.",
    )
    async def func(self, context: commands.Context, cog_name: str, request: str) -> None:
        # Create the generation config
        generation_config = {
            "temperature": 1,
            "top_p": 0.95,
            "top_k": 40,
            "max_output_tokens": 8192,
            "response_mime_type": "text/plain",
        }

        model = genai.GenerativeModel(
            model_name="gemini-1.5-pro",
            generation_config=generation_config,
        )

        # Define the template to be sent to Gemini
        template = f"""
from discord.ext import commands 
from discord.ext.commands import Context 

class {cog_name.capitalize()}(commands.Cog, name="{cog_name}"):
    def __init__(self, bot) -> None:
        self.bot = bot
    @commands.hybrid_command(
        name="{cog_name}",
        description="This is a command generated by your request.",
    )
    async def {cog_name}(self, context: Context) -> None:
        pass

async def setup(bot) -> None:
    await bot.add_cog({cog_name.capitalize()}(bot))
"""

        # Send the template to Gemini for further processing without the system role
        chat_session = model.start_chat(
            history=[
                {
                    "role": "user",
                    "parts": [
                        f"complete the template:\n{template}\n to fulfill in the function logic for '{request}'. Only respond with the full template code! don't change the name and async def name ",
                    ],
                },
            ]
        )

        response = chat_session.send_message("Generate a function code.")
        code = response.text

        # Create embed for the code
        embed = discord.Embed(title=f"Generated Code for {cog_name}", description="Here is the generated code:", color=discord.Color.blue())

        # Split the code into chunks if it exceeds 1024 characters
        code_lines = code.splitlines()
        current_chunk = ""
        chunk_count = 0

        for line in code_lines:
            # Add the line to the current chunk if it fits
            if len(current_chunk) + len(line) + 1 <= 1024:  # +1 for the newline character
                current_chunk += line + "\n"
            else:
                embed.add_field(name=f"Code Part {chunk_count + 1}", value=current_chunk.strip(), inline=False)
                chunk_count += 1
                current_chunk = line + "\n"  # Start a new chunk with the current line

        # Add the last chunk if it exists
        if current_chunk:
            embed.add_field(name=f"Code Part {chunk_count + 1}", value=current_chunk.strip(), inline=False)

        # Create buttons for the response
        accept_button = Button(label="Accept", style=discord.ButtonStyle.success)
        edit_button = Button(label="Edit", style=discord.ButtonStyle.primary)
        cancel_button = Button(label="Cancel", style=discord.ButtonStyle.danger)

        async def accept_callback(interaction: discord.Interaction):
            if interaction.user != context.author:
                await interaction.response.send_message("You cannot accept this. It's not your command!", ephemeral=True)
                return
            
            # Define the directory and ensure it exists
            cogs_directory = "cogs"
            os.makedirs(cogs_directory, exist_ok=True)  # Create the cogs directory if it doesn't exist

            try:
                # Clean the code by splitting into lines and removing the first and last lines
                cleaned_code_lines = code.strip().splitlines()
                
                if len(cleaned_code_lines) > 2:
                    cleaned_code = "\n".join(cleaned_code_lines[1:-1])  # Remove the first and last line
                elif len(cleaned_code_lines) == 2:
                    cleaned_code = cleaned_code_lines[1]  # If there are only two lines, keep the second one
                else:
                    cleaned_code = cleaned_code_lines[0] if cleaned_code_lines else ""  # Just keep it if there is only one line

                file_name = f"{cogs_directory}/{cog_name}.py"
                with open(file_name, "w") as f:
                    f.write(cleaned_code)
                await interaction.response.send_message(f"File '{file_name}' created successfully!", ephemeral=True)
            except Exception as e:
                await interaction.response.send_message(f"An error occurred while creating the file: {str(e)}", ephemeral=True)

        async def edit_callback(interaction: discord.Interaction):
            if interaction.user != context.author:
                await interaction.response.send_message("You cannot edit this. It's not your command!", ephemeral=True)
                return

            await interaction.response.send_message("Please send the edited version of the code:", ephemeral=True)

            def check(msg):
                return msg.author == context.author and msg.channel == context.channel

            try:
                msg = await self.bot.wait_for('message', check=check, timeout=60.0)
                edited_code = msg.content
                await interaction.followup.send(f"Edited code received:\n```python\n{edited_code}\n```", ephemeral=True)
            except asyncio.TimeoutError:
                await interaction.followup.send("You took too long to respond. Editing cancelled.", ephemeral=True)

        async def cancel_callback(interaction: discord.Interaction):
            await interaction.response.send_message("Operation cancelled.", ephemeral=True)

        accept_button.callback = accept_callback
        edit_button.callback = edit_callback
        cancel_button.callback = cancel_callback

        view = View()
        view.add_item(accept_button)
        view.add_item(edit_button)
        view.add_item(cancel_button)

        await context.send(embed=embed, view=view)

async def setup(bot) -> None:
    await bot.add_cog(FuncCommand(bot))
